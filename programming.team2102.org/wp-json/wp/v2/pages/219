{"id":219,"date":"2021-04-06T19:36:35","date_gmt":"2021-04-06T19:36:35","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=219"},"modified":"2024-09-04T18:45:04","modified_gmt":"2024-09-04T18:45:04","slug":"drive-straight","status":"publish","type":"page","link":"http:\/\/programming.team2102.org\/drive-straight\/","title":{"rendered":"Drive Straight"},"content":{"rendered":"\n<p>Now that we have the ability to control the speed of the motors let\u2019s change our&nbsp;<strong>DriveForDistanceCommand<\/strong>&nbsp;so to use speed rather than power to make the robot drive more straight. Open your&nbsp;<strong>DriveForDistanceCommand.java<\/strong>&nbsp;file and change the&nbsp;<strong>s<\/strong><strong>etPower<\/strong>&nbsp;calls to&nbsp;<strong>s<\/strong><strong>etSpeed<\/strong>&nbsp;calls. Also since we are now using speed rather than power let\u2019s rename the&nbsp;<strong>power<\/strong>&nbsp;parameter to&nbsp;<strong>speed<\/strong>. The best way to do this is to use VS Studio\u2019s&nbsp;<strong>Rename<\/strong>&nbsp;function. Right click on the parameter&nbsp;<strong>power&nbsp;<\/strong>and choose&nbsp;<strong>Rename Symbol<\/strong>, then change the name to&nbsp;<strong>power<\/strong>. Note that this changes all instances in your program automatically. Let\u2019s do the same for the member variable&nbsp;<strong>m_power<\/strong>, changing it to&nbsp;<strong>m_speed<\/strong>.<\/p>\n\n\n\n<p>Your&nbsp;<strong>DriveForDistanceCommand.java<\/strong>&nbsp;file should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\r\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\r\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\r\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\r\n\/* the project.                                                               *\/\r\n\/*----------------------------------------------------------------------------*\/\r\n\r\npackage frc.robot.commands;\r\n\r\nimport edu.wpi.first.wpilibj2.command.Command;\r\nimport frc.robot.subsystems.DriveSubsystem;\r\nimport robotCore.Encoder;\r\nimport robotCore.Logger;\r\n\r\n\/**\r\n * An example command that uses an example subsystem.\r\n *\/\r\npublic class DriveForDistanceCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_distance;\r\n  private Encoder m_leftEncoder;\r\n\r\n  \/**\r\n   * Creates a new DriveForDistanceCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public DriveForDistanceCommand(DriveSubsystem subsystem, double speed, double distance) {\r\n    Logger.log(\"DriveForDistanceCommand\", 3, \"DriveForDistanceCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_distance = distance;\r\n    m_leftEncoder = subsystem.getLeftEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }\r\n\r\n  \/\/ Called when the command is initially scheduled.\r\n  @Override\r\n  public void initialize() {\r\n    Logger.log(\"DriveForDistanceCommand\", 2, \"initialize()\");\r\n\r\n    m_leftEncoder.reset();\r\n\r\n    m_subsystem.setSpeed(m_speed, m_speed);\r\n  }\r\n\r\n  \/\/ Called every time the scheduler runs while the command is scheduled.\r\n  @Override\r\n  public void execute() {\r\n    Logger.log(\"DriveForDistanceCommand\", -1, \"execute()\");\r\n  }\r\n\r\n  \/\/ Called once the command ends or is interrupted.\r\n  @Override\r\n  public void end(boolean interrupted) {\r\n    Logger.log(\"DriveForDistanceCommand\", 2, String.format(\"end(%b)\", interrupted));\r\n\r\n    m_subsystem.setPower(0, 0);\r\n  }\r\n\r\n  \/\/ Returns true when the command should end.\r\n  @Override\r\n  public boolean isFinished() {\r\n    Logger.log(\"DriveForDistanceCommand\", -1, \"isFinished()\");\r\n\r\n    return (m_leftEncoder.get() >= m_distance);\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<p>Now if you deploy and run the (remember that this command is tied to button&nbsp;<strong>2<\/strong>&nbsp;on the joystick), you will see that once the robot gets going, it drives pretty straight. However while it is starting up, it&nbsp;may turn a little bit. This is because, as we saw from the speed graphs in the previous chapter, that the motors do not start up quite in sync. What we want is a way to measure if the robot has turned and compensate the power so that it drives in a straight line.<\/p>\n\n\n\n<p>To do this, we are going to change our&nbsp;<strong>DriveForDistanceCommand<\/strong>&nbsp;to use both the left and right encoders to keep the robot driving straight. To do this we are going to need to access both the left and right encoders (currently we are only using the left encoder to measure the distance the robot has traveled). Add a declaration for&nbsp;<strong>m_rightEncoder<\/strong>&nbsp;and initialize it in the constructor:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public class DriveForDistanceCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_distance;\r\n  private Encoder m_leftEncoder;\r\n  private Encoder m_rightEncoder;\r\n\r\n  \/**\r\n   * Creates a new DriveForDistanceCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public DriveForDistanceCommand(DriveSubsystem subsystem, double speed, double distance) {\r\n    Logger.log(\"DriveForDistanceCommand\", 3, \"DriveForDistanceCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_distance = distance;\r\n    m_leftEncoder = subsystem.getLeftEncoder();\r\n    m_rightEncoder = subsystem.getRightEncoder();<\/code><\/pre>\n\n\n\n<p>In the&nbsp;<strong>initialize()<\/strong>&nbsp;function we need to reset the right encoder:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void initialize() {\n    Logger.log(\"DriveForDistanceCommand\", 2, \"initialize()\");\n\n    m_leftEncoder.reset();\n    m_rightEncoder.reset();\n\n    m_subsystem.setSpeed(m_speed, m_speed);\n  }<\/code><\/pre>\n\n\n\n<p>Now in the&nbsp;<strong>execute()<\/strong>&nbsp;function we are going to adjust the speed of the motors to keep the robot driving straight. The first thing we want to do is to get the current left and right encoder values and compute the difference between the two:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"DriveForDistanceCommand\", -1, \"execute()\");\n\n    int leftDistance = m_leftEncoder.get();\n    int rightDistance = m_rightEncoder.get();\n    int deltaDistance = rightDistance - leftDistance;\n  }<\/code><\/pre>\n\n\n\n<p>Now if the robot is driving straight then&nbsp;<strong>deltaDistance<\/strong>&nbsp;should be zero because the left and right wheels have turned by the same amount. It is, therefore, our goal to keep this&nbsp;<strong>deltaDistance<\/strong>&nbsp;as close to zero as we can at all times. If&nbsp;<strong>deltaDistance<\/strong>&nbsp;is positive, then this means that the right wheel has turned farther than the left and we need to slow it down&nbsp;and speed up the left. Conversely, if&nbsp;<strong>deltaDistance<\/strong>&nbsp;is negative then the left wheel is running too fast and we need to slow it down and speed up the right. Conceptually we want to subtract the&nbsp;<strong>deltaDistance<\/strong>&nbsp;from the speed of the right motor and add it to the speed of the left motor. Something like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_subsystem.setSpeed(m_speed + deltaDistance, m_speed - deltaDistance);<\/code><\/pre>\n\n\n\n<p>This is not quite what we want, however. Remember that the speed value should be in the range of\u00a0<strong>-1.0<\/strong>\u00a0to\u00a0<strong>+1.0<\/strong>. So if the difference between the left and right distance is greater than or equal to one, it will slam the robot to the left or right at full power which is not what we want. So what we need to do is to scale the\u00a0<strong>deltaDistance<\/strong>\u00a0by some fractional constant. Let&#8217;s start with a scale factor of\u00a0<strong>0.00<\/strong>5:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_subsystem.setSpeed(m_speed + deltaDistance * k_scale, m_speed - deltaDistance * k_scale);<\/code><\/pre>\n\n\n\n<p>Once again we are defining the scale factor as a constant&nbsp;<strong>k_scale<\/strong>&nbsp;which we define as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public class DriveForDistanceCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_distance;\r\n  private Encoder m_leftEncoder;\r\n  private Encoder m_rightEncoder;\r\n\r\n  private static final double k_scale\t= 0.005;<\/code><\/pre>\n\n\n\n<p>The completed&nbsp;<strong>execute()<\/strong>&nbsp;function should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void execute() {\n    Logger.log(\"DriveForDistanceCommand\", -1, \"execute()\");\n\n    int leftDistance\t= m_leftEncoder.get();\n    int\trightDistance\t= m_rightEncoder.get();\n    int\tdeltaDistance\t= rightDistance - leftDistance;\n\n    m_subsystem.setSpeed(m_speed + deltaDistance * k_scale, m_speed - deltaDistance * k_scale);\n  }<\/code><\/pre>\n\n\n\n<p>Your DriveForDistanceCommand.java file should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\r\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\r\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\r\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\r\n\/* the project.                                                               *\/\r\n\/*----------------------------------------------------------------------------*\/\r\n\r\npackage frc.robot.commands;\r\n\r\nimport edu.wpi.first.wpilibj2.command.Command;\r\nimport frc.robot.subsystems.DriveSubsystem;\r\nimport robotCore.Encoder;\r\nimport robotCore.Logger;\r\n\r\n\/**\r\n * Creates a new DriveForDistanceCommand.\r\n *\r\n * @param subsystem The subsystem used by this command.\r\n *\/\r\npublic class DriveForDistanceCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_distance;\r\n  private Encoder m_leftEncoder;\r\n  private Encoder m_rightEncoder;\r\n\r\n  private static final double k_scale\t= 0.005;\r\n  \/**\r\n   * Creates a new DriveForDistanceCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public DriveForDistanceCommand(DriveSubsystem subsystem, double speed, double distance) {\r\n    Logger.log(\"DriveForDistanceCommand\", 3, \"DriveForDistanceCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_distance = distance;\r\n    m_leftEncoder = subsystem.getLeftEncoder();\r\n    m_rightEncoder = subsystem.getRightEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }\r\n\r\n  \/\/ Called when the command is initially scheduled.\r\n  @Override\r\n  public void initialize() {\r\n    Logger.log(\"DriveForDistanceCommand\", 2, \"initialize()\");\r\n\r\n    m_leftEncoder.reset();\r\n    m_rightEncoder.reset();\r\n\r\n    m_subsystem.setSpeed(m_speed, m_speed);\r\n  }\r\n\r\n  \/\/ Called every time the scheduler runs while the command is scheduled.\r\n  @Override\r\n  public void execute() {\r\n    Logger.log(\"DriveForDistanceCommand\", -1, \"execute()\");\r\n\r\n    int leftDistance\t= m_leftEncoder.get();\r\n    int\trightDistance\t= m_rightEncoder.get();\r\n    int\tdeltaDistance\t= rightDistance - leftDistance;\r\n\r\n    m_subsystem.setSpeed(m_speed + deltaDistance * k_scale, m_speed - deltaDistance * k_scale);\r\n  }\r\n\r\n  \/\/ Called once the command ends or is interrupted.\r\n  @Override\r\n  public void end(boolean interrupted) {\r\n    Logger.log(\"DriveForDistanceCommand\", 2, String.format(\"end(%b)\", interrupted));\r\n\r\n    m_subsystem.setPower(0, 0);\r\n  }\r\n\r\n  \/\/ Returns true when the command should end.\r\n  @Override\r\n  public boolean isFinished() {\r\n    Logger.log(\"DriveForDistanceCommand\", -1, \"isFinished()\");\r\n\r\n    return (m_leftEncoder.get() >= m_distance);\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<p>Now deploy and run your program. You should see that the robot does a better job of driving straight. The size of the\u00a0<strong>k_scale<\/strong>\u00a0factor will control how quickly the robot corrects it\u2019s direction. Like we did with the <strong>PID<\/strong> tuning for the drive motors, we would like <strong>k_scale<\/strong> to be as large as possible without creating any instability. In my case I was able to increase it to <strong>0.01<\/strong> but larger than that cause it to oscillate. <\/p>\n\n\n\n<p>There are other mechanisms that you can use to keep your robot driving in a particular direction. For example, if your robot has a <strong>gyroscope sensor<\/strong> which reports it current orientation, you can use that sensor in a similar manner to drive a straight line. You would adjust the left and right motor speeds based on how far the robot is deviating from the desired direction. This mechanism has the advantage on not being affected by any wheel slippage that might occur, which would cause errors when using our wheel encoder method.<\/p>\n\n\n\n<p>Before we move on, let\u2019s make one more change to our&nbsp;<strong>DriveForDistanceCommand<\/strong>. Specifying the distance in encoder units is OK, but it would really be nice if we could use real world units like&nbsp;inches instead. To do that we will need to compute a conversion factor that will convert inches into the encoder units.<\/p>\n\n\n\n<p>Set the robot up to run the&nbsp;<strong>DriveForDistanceCommand<\/strong>&nbsp;again, but this time put a piece of tape on the floor to mark it\u2019s starting position. Then run your program and mark the position where the robot ends and measure the distance it traveled using a tape measure.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>You should find that the robot moves about\u00a0<strong>42.5 inches<\/strong>. This means that\u00a0<strong>2000 encoder units<\/strong>\u00a0is equal to\u00a0<strong>42.5 inches<\/strong>. So if we want to pass in the distance in\u00a0<strong>inches<\/strong>, we will need to multiply that by\u00a0<strong>(2000\/42.5)<\/strong>\u00a0to get\u00a0<strong>encoder units<\/strong>. Change the\u00a0<strong>DriveForDistanceCommand<\/strong>\u00a0constructor to perform this calculation:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public DriveForDistanceCommand(DriveSubsystem subsystem, double speed, double distance) {\r\n    Logger.log(\"DriveForDistanceCommand\", 3, \"DriveForDistanceCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_distance = distance * k_ticksPerInch;\r\n    m_leftEncoder = subsystem.getLeftEncoder();\r\n    m_rightEncoder = subsystem.getRightEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }<\/code><\/pre>\n\n\n\n<p>Where we defined <strong>k_ticksPerInch<\/strong> as:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private static final double k_ticksPerInch = 2000 \/ 42.5;<\/code><\/pre>\n\n\n\n<p>Finally change your <strong>RobotContainer.java<\/strong> file to specify that the robot drive for <strong>30<\/strong> inches and give it a try.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private void configureButtonBindings() {\r\n    m_joystick.button(1).onTrue(new DriveForTimeCommand(m_driveSubsystem, 0.50, 3.0));\r\n    m_joystick.button(2).onTrue(new DriveForDistanceCommand(m_driveSubsystem, 0.75, 30));\r\n    m_joystick.button(3).onTrue(new TestMotorSpeedCommand(m_driveSubsystem));\r\n    m_joystick.button(4).whileTrue(new CalibrateSpeedCommand(m_driveSubsystem));\r\n  }<\/code><\/pre>\n\n\n\n<p>One final note. This command, as written, will only drive the robot forward. If you attempt to drive backwards by setting the speed negative, you will find the robot never stops. It is left as an exercise for the reader to fix the program so that it can successfully drive either forward or backward.<\/p>\n\n\n\n<p><a href=\"\/turn-command\/\" data-type=\"page\">Next: Turn Command<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Now that we have the ability to control the speed of the motors let\u2019s change our&nbsp;DriveForDistanceCommand&nbsp;so to use speed rather than power to make the robot drive more straight. Open your&nbsp;DriveForDistanceCommand.java&nbsp;file and change the&nbsp;setPower&nbsp;calls to&nbsp;setSpeed&nbsp;calls. Also since we are now using speed rather than power let\u2019s rename the&nbsp;power&nbsp;parameter to&nbsp;speed. The best way to do this&hellip;&nbsp;<a href=\"http:\/\/programming.team2102.org\/drive-straight\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Drive Straight<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"open","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/219"}],"collection":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/comments?post=219"}],"version-history":[{"count":22,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/219\/revisions"}],"predecessor-version":[{"id":3254,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/219\/revisions\/3254"}],"wp:attachment":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/media?parent=219"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}