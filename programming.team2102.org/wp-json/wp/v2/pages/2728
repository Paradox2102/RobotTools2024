{"id":2728,"date":"2024-08-05T02:08:36","date_gmt":"2024-08-05T02:08:36","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=2728"},"modified":"2024-09-02T19:14:16","modified_gmt":"2024-09-02T19:14:16","slug":"drive-subsystem-3","status":"publish","type":"page","link":"http:\/\/programming.team2102.org\/drive-subsystem-3\/","title":{"rendered":"Drive Subsystem"},"content":{"rendered":"\n<p>The drive subsystem for a <strong>swerve drive<\/strong> robot is considerably more complex than that of the simple <strong>tank drive<\/strong> that you created for the <strong>Minibot<\/strong>. If you don&#8217;t remember how to create a new subsystem, you can review the procedure from the <strong>Minibot <\/strong>tutorial <a href=\"\/drive-subsystem\/\">here<\/a>.<\/p>\n\n\n\n<p>The robot&#8217;s motion is controlled by eight motors grouped in pairs, with one pair on each of the four corners of the robot. We will refer to each of these pairs of motors as a<strong> Swerve Module<\/strong>:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/SwerveModulesHighlight-976x1024.jpg\" alt=\"\" class=\"wp-image-2739\" width=\"434\" height=\"455\" srcset=\"http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModulesHighlight-976x1024.jpg 976w, http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModulesHighlight-286x300.jpg 286w, http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModulesHighlight-150x157.jpg 150w, http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModulesHighlight-768x806.jpg 768w, http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModulesHighlight.jpg 1024w\" sizes=\"(max-width: 434px) 100vw, 434px\" \/><\/figure><\/div>\n\n\n\n<p>The yellow box in this image shows one of these modules. In particular this is the Swerve Module for the front left corner of the robot. If we view this module from a different angle we can see the two motors which control this wheel:<\/p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large is-resized\"><img loading=\"lazy\" src=\"\/wp-content\/uploads\/2024\/08\/SwerveModuleAnotated-1-961x1024.jpg\" alt=\"\" class=\"wp-image-2779\" width=\"436\" height=\"463\" srcset=\"http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModuleAnotated-1-282x300.jpg 282w, http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModuleAnotated-1-150x160.jpg 150w, http:\/\/programming.team2102.org\/wp-content\/uploads\/2024\/08\/SwerveModuleAnotated-1-768x818.jpg 768w\" sizes=\"(max-width: 436px) 100vw, 436px\" \/><\/figure><\/div>\n\n\n\n<p>The motor marked <strong>Steering <\/strong>controls the orientation of the wheel. The wheel is free to rotate a full 360 degrees. The motor marked <strong>Drive <\/strong>powers the wheel and drives the robot.<\/p>\n\n\n\n<h4>SwerveModule class<\/h4>\n\n\n\n<p>Since we will have four of these modules for our robot, we need to create a class which we will call <strong>SwerveModule<\/strong>. Each instance of this class will control the two motors for that specific module. We will need to create four instances of this class, one for each corner of the robot. This class does not need to be defined as a subsystem, and should just be a simple class something like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>package frc.robot.subsystems;\n\npublic class SwerveModule {\n    private final PWMMotor m_driveMotor;\n    private final PWMMotor m_steeringMotor;\n    private final Encoder m_driveEncoder;\n    private final Encoder m_steeringEncoder;\n\n    public SwerveModule(int drivePWM, int driveDir, int driveEncInt, int driveEncDir, int turnPWM, int turnDir,\n                       int turnEncA, int turnEncB,  int i2cAddr, String name) {\n\n    }\n}<\/code><\/pre>\n\n\n\n<h4>Initializing motors<\/h4>\n\n\n\n<p>Since each <strong>Swerve Module<\/strong> will control two motors, we will need the pin numbers for each of the motors. To instantiate the motors you will need something like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>        m_driveMotor = new PWMMotor(drivePWM, driveDir, i2cAddr);\n        m_steeringMotor = new PWMMotor(steeringPWM, steeringDir, i2cAddr);<\/code><\/pre>\n\n\n\n<p>Note that we are using the constructor which includes the <strong>I2C <\/strong>address.<\/p>\n\n\n\n<h4>Initializing encoders<\/h4>\n\n\n\n<p>In addition, each motor has an associated <strong>encoder<\/strong>. For the <strong>Drive<\/strong> motor we use a relative <strong><a href=\"\/RobotCoreDoc\/enumrobot_core_1_1_encoder_1_1_encoder_type.html#a6f59fea1f2990c6af4c6f241fa47cfe8\">Quadrature<\/a> <\/strong>encoder. for the <strong>Steering <\/strong>motor we use an absolute <strong><a href=\"\/RobotCoreDoc\/enumrobot_core_1_1_encoder_1_1_encoder_type.html#a155b40b93e8ce4e8e1ff9d48498e3eb9\">AnalogRotational<\/a><\/strong> encoder. Hence we will also need the four pins the configure the two encoders. To instantiate the encoders you will need something like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>        m_steeringEncoder = new Encoder(robotCore.Encoder.EncoderType.AnalogRotational, steeringEncA, steeringEncB,\n                i2cAddr, true);\n        m_driveEncoder = new Encoder(robotCore.Encoder.EncoderType.Quadrature, driveEncInt, driveEncDir, i2cAddr, true);<\/code><\/pre>\n\n\n\n<p>Once again note that we are using the constructor with the <strong>I2C <\/strong>address. Also note the last parameter <strong><em><a href=\"\/RobotCoreDoc\/classrobot_core_1_1_encoder.html#a25d192b9eed3e0f5d1e534d6e6675e9e\">group<\/a><\/em><\/strong>. If this is set to <strong>true <\/strong>then the read of the speed or position for the encoders are grouped at a low level to reduce the time needed to retrieve this information from the motors. <strong>In order to have sufficient bandwidth to operate the swerve drive it is important that <em><a href=\"\/RobotCoreDoc\/classrobot_core_1_1_encoder.html#a25d192b9eed3e0f5d1e534d6e6675e9e\">group<\/a> <\/em>be set to true for these two encoders<\/strong>.<\/p>\n\n\n\n<p>Finally, don&#8217;t forget to set the feedback device for the two motors:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>        m_driveMotor.setFeedbackDevice(m_driveEncoder);\n        m_steeringMotor.setFeedbackDevice(m_steeringEncoder);<\/code><\/pre>\n\n\n\n<h4>DriveSubsystem<\/h4>\n\n\n\n<p>Finally, when you create the <strong>DriveSubsystem<\/strong>, you will need to create four instances of your <strong>SwerveModule <\/strong>class. You will, of course, need to know all of the required pin number. Hence your DriveSubsystem class should look something like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>package frc.robot.subsystems;\n\nimport edu.wpi.first.wpilibj2.command.SubsystemBase;\nimport robotCore.Device;\nimport robotCore.Logger;\n\npublic class DriveSubsystem extends SubsystemBase {\n  public static final int FLI2CAddr = 5;\n  public static final int FLDrivePWM = Device.M1_1_PWM;\n  public static final int FLDriveDir = Device.M1_1_DIR;\n  public static final int FLTurnPWM = Device.M1_2_PWM;\n  public static final int FLTurnDir = Device.M1_2_DIR;\n  public static final int FLDriveEncInt = Device.Q1_INT;\n  public static final int FLDriveEncDir = Device.Q1_DIR;\n  public static final int FLTurnEncA = Device.A1_A;\n  public static final int FLTurnEncB = Device.A1_B;\n\n  public static final int BLI2CAddr = 5;\n  public static final int BLDrivePWM = Device.M2_1_PWM;\n  public static final int BLDriveDir = Device.M2_1_DIR;\n  private static final int BLTurnPWM = Device.M2_2_PWM;\n  private static final int BLTurnDir = Device.M2_2_DIR;\n  public static final int BLDriveEncInt = Device.Q2_INT;\n  public static final int BLDriveEncDir = Device.Q2_DIR;\n  public static final int BLTurnEncA = Device.A2_A;\n  public static final int BLTurnEncB = Device.A2_B;\n\n  public static final int BRI2CAddr = 6;\n  public static final int BRDrivePWM = Device.M1_1_PWM;\n  public static final int BRDriveDir = Device.M1_1_DIR;\n  public static final int BRTurnPWM = Device.M1_2_PWM;\n  public static final int BRTurnDir = Device.M1_2_DIR;\n  private static final int BRDriveEncInt = Device.Q1_INT;\n  private static final int BRDriveEncDir = Device.Q1_DIR;\n  private static final int BRTurnEncA = Device.A1_A;\n  private static final int BRTurnEncB = Device.A1_B;\n\n  private static final int FRI2CAddr = 6;\n  private static final int FRDrivePWM = Device.M2_1_PWM;\n  private static final int FRDriveDir = Device.M2_1_DIR;\n  private static final int FRTurnPWM = Device.M2_2_PWM;\n  private static final int FRTurnDir = Device.M2_2_DIR;\n  private static final int FRDriveEncInt = Device.Q2_INT;\n  private static final int FRDriveEncDir = Device.Q2_DIR;\n  private static final int FRTurnEncA = Device.A2_A;\n  private static final int FRTurnEncB = Device.A2_B;\n\n  SwerveModule m_frontLeft = new SwerveModule(FLDrivePWM, FLDriveDir, FLDriveEncInt, FLDriveEncDir,\n      FLTurnPWM, FLTurnDir, FLTurnEncA, FLTurnEncB, FLI2CAddr, \"FrontLeft\");\n  SwerveModule m_backLeft = new SwerveModule(BLDrivePWM, BLDriveDir, BLDriveEncInt, BLDriveEncDir,\n      BLTurnPWM, BLTurnDir, BLTurnEncA, BLTurnEncB, BLI2CAddr, \"BackLeft\");\n  SwerveModule m_backRight = new SwerveModule(BRDrivePWM, BRDriveDir, BRDriveEncInt, BRDriveEncDir,\n      BRTurnPWM, BRTurnDir, BRTurnEncA, BRTurnEncB, BRI2CAddr, \"BackRight\");\n  SwerveModule m_frontRight = new SwerveModule(FRDrivePWM, FRDriveDir, FRDriveEncInt, FRDriveEncDir,\n      FRTurnPWM, FRTurnDir, FRTurnEncA, FRTurnEncB, FRI2CAddr, \"FrontRight\");\n\n  \/**\n   * Creates a new DriveSubsystem.\n   *\/\n  public DriveSubsystem() {\n    Logger.log(\"DriveSubsystem\", 3, \"DriveSubsystem()\");\n  }\n\n  @Override\n  public void periodic() {\n    \/\/ This method will be called once per scheduler run\n    Logger.log(\"DriveSubsystem\", -1, \"periodic()\");\n  }\n}<\/code><\/pre>\n\n\n\n<p>In the next section we will tune the PID for the <strong>Steering <\/strong>motors.<\/p>\n\n\n\n<p><a href=\"\/rotation-motor-tuning\/\" data-type=\"page\">Next: Steering Motor Tuning<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>The drive subsystem for a swerve drive robot is considerably more complex than that of the simple tank drive that you created for the Minibot. If you don&#8217;t remember how to create a new subsystem, you can review the procedure from the Minibot tutorial here. The robot&#8217;s motion is controlled by eight motors grouped in&hellip;&nbsp;<a href=\"http:\/\/programming.team2102.org\/drive-subsystem-3\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Drive Subsystem<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/2728"}],"collection":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/comments?post=2728"}],"version-history":[{"count":35,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/2728\/revisions"}],"predecessor-version":[{"id":3141,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/2728\/revisions\/3141"}],"wp:attachment":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/media?parent=2728"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}