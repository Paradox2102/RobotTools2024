{"id":225,"date":"2021-04-06T20:27:33","date_gmt":"2021-04-06T20:27:33","guid":{"rendered":"http:\/\/gabybot.com\/?page_id=225"},"modified":"2024-09-04T19:01:45","modified_gmt":"2024-09-04T19:01:45","slug":"turn-command","status":"publish","type":"page","link":"http:\/\/programming.team2102.org\/turn-command\/","title":{"rendered":"Turn Command"},"content":{"rendered":"\n<p>Next we are going to create a command called&nbsp;<strong>TurnCommand<\/strong>&nbsp;which will allow us to turn the robot in place by a specified angle. You should know enough now to create the framework for this command. We will want to specify the speed&nbsp;to be used in the turn as well as the angle so create the constructor for your class so that it takes two&nbsp;<strong>double<\/strong>&nbsp;parameters, the first to specify the&nbsp;<strong>speed&nbsp;<\/strong>and the second to specify the&nbsp;<strong>angle<\/strong>. After you have created the new command, compare you code to the code below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\r\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\r\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\r\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\r\n\/* the project.                                                               *\/\r\n\/*----------------------------------------------------------------------------*\/\r\n\r\npackage frc.robot.commands;\r\n\r\nimport edu.wpi.first.wpilibj2.command.Command;\r\nimport frc.robot.subsystems.DriveSubsystem;\r\nimport robotCore.Logger;\r\n\r\n\/**\r\n * An example command that uses an example subsystem.\r\n *\/\r\npublic class TurnCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_angle;\r\n\r\n  \/**\r\n   * Creates a new TurnCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\r\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_angle = angle;\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }\r\n\r\n  \/\/ Called when the command is initially scheduled.\r\n  @Override\r\n  public void initialize() {\r\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\r\n  }\r\n\r\n  \/\/ Called every time the scheduler runs while the command is scheduled.\r\n  @Override\r\n  public void execute() {\r\n    Logger.log(\"TurnCommand\", -1, \"execute()\");\r\n  }\r\n\r\n  \/\/ Called once the command ends or is interrupted.\r\n  @Override\r\n  public void end(boolean interrupted) {\r\n    Logger.log(\"TurnCommand\", 2, String.format(\"end(%b)\", interrupted));\r\n  }\r\n\r\n  \/\/ Returns true when the command should end.\r\n  @Override\r\n  public boolean isFinished() {\r\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\r\n    return false;\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<p>Did you create some member variables (e.g.&nbsp;<strong>m_speed<\/strong>&nbsp;and&nbsp;<strong>m_angle<\/strong>) to store the speed and angle that are passed in on the constructor?<\/p>\n\n\n\n<p>Now we are going to use the encoders to measure the turn. Once again, we will want to use copies of the encoders like we did in our&nbsp;<strong>DriveForDistanceCommand<\/strong>. Add code to declare and initialize the left and right encoder:<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>public class TurnCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_angle;\r\n  private Encoder m_leftEncoder;\r\n  private Encoder m_rightEncoder;\r\n\r\n  \/**\r\n   * Creates a new TurnCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\r\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_angle = angle;\r\n    m_leftEncoder = m_subsystem.getLeftEncoder();\r\n    m_rightEncoder = m_subsystem.getRightEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }<\/code><\/pre>\n\n\n\n<p>Now in the&nbsp;<strong>initialize()<\/strong>&nbsp;function we also want reset the encoders and turn the motors on. To make the robot turn, we need to set the speed to the left and right motors opposite, and we need to set the signs so that it turns in the correct direction. Let\u2019s say that a positive&nbsp;<strong>angle<\/strong>&nbsp;should&nbsp;make the robot turn to the right (clockwise) and a negative&nbsp;<strong>angle<\/strong>&nbsp;should&nbsp;make the robot turn to the left (anticlockwise). See if you can add code to your&nbsp;<strong>initialize()<\/strong>&nbsp;function to accomplish this and then check your result with the one below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public void initialize() {\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\n\n    m_leftEncoder.reset();\n    m_rightEncoder.reset();\n\n    if (m_angle &lt; 0)\n    {\n        m_subsystem.setSpeed(-m_speed, m_speed);    \/\/ Turn left\n    }\n    else\n    {\n        m_subsystem.setSpeed(m_speed, -m_speed);    \/\/ Turn right\n    }\n  }<\/code><\/pre>\n\n\n\n<p>Now we need to add some code to the&nbsp;<strong>isFinished()<\/strong>&nbsp;function to return&nbsp;<strong>true<\/strong>&nbsp;when the robot has turned by the requested angle. Add the following line to the&nbsp;<strong>isFinished()<\/strong>&nbsp;function:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    \tint\tdelta\t= m_leftEncoder.get() - m_rightEncoder.get();<\/code><\/pre>\n\n\n\n<p>Note that&nbsp;<strong>delta<\/strong>&nbsp;will be&nbsp;<strong>positive<\/strong>&nbsp;if the robot is turning right (i.e. the left wheel is moving forward and the right wheel is moving backward), and&nbsp;<strong>negative<\/strong>&nbsp;if the robot is turning left. The magnitude of&nbsp;<strong>delta<\/strong>&nbsp;will also be a measure of how far the robot is turned. So lets return&nbsp;<strong>true<\/strong>&nbsp;when the magnitude of&nbsp;<strong>delta<\/strong>&nbsp;exceeds the magnitude of the&nbsp;<strong>angle<\/strong>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public boolean isFinished() {\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\n\n    int delta = m_leftEncoder.get() - m_rightEncoder.get();\n\n    return (Math.abs(delta) &gt;= Math.abs(m_angle));\n  }<\/code><\/pre>\n\n\n\n<p>Note that we are using the absolute value of both&nbsp;<strong>delta<\/strong>&nbsp;and&nbsp;<strong>m_angle<\/strong>&nbsp;in the comparison since they can both be negative.<\/p>\n\n\n\n<p>Remember to turn the motors back off in the&nbsp;<strong>end()<\/strong>&nbsp;function. Your&nbsp;<strong>TurnCommand.java<\/strong>&nbsp;file should now look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\r\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\r\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\r\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\r\n\/* the project.                                                               *\/\r\n\/*----------------------------------------------------------------------------*\/\r\n\r\npackage frc.robot.commands;\r\n\r\nimport edu.wpi.first.wpilibj2.command.Command;\r\nimport frc.robot.subsystems.DriveSubsystem;\r\nimport robotCore.Encoder;\r\nimport robotCore.Logger;\r\n\r\n\/**\r\n * An example command that uses an example subsystem.\r\n *\/\r\npublic class TurnCommand extends Command {\r\n  private final DriveSubsystem m_subsystem;\r\n  private double m_speed;\r\n  private double m_angle;\r\n  private Encoder m_leftEncoder;\r\n  private Encoder m_rightEncoder;\r\n\r\n  \/**\r\n   * Creates a new TurnCommand.\r\n   *\r\n   * @param subsystem The subsystem used by this command.\r\n   *\/\r\n  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\r\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_angle = angle;\r\n    m_leftEncoder = m_subsystem.getLeftEncoder();\r\n    m_rightEncoder = m_subsystem.getRightEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }\r\n\r\n  \/\/ Called when the command is initially scheduled.\r\n  @Override\r\n  public void initialize() {\r\n    Logger.log(\"TurnCommand\", 2, \"initialize()\");\r\n\r\n    m_leftEncoder.reset();\r\n    m_rightEncoder.reset();\r\n\r\n    if (m_angle &lt; 0)\r\n    {\r\n        m_subsystem.setSpeed(-m_speed, m_speed);    \/\/ Turn left\r\n    }\r\n    else\r\n    {\r\n        m_subsystem.setSpeed(m_speed, -m_speed);    \/\/ Turn right\r\n    }\r\n  }\r\n\r\n  \/\/ Called every time the scheduler runs while the command is scheduled.\r\n  @Override\r\n  public void execute() {\r\n    Logger.log(\"TurnCommand\", -1, \"execute()\");\r\n  }\r\n\r\n  \/\/ Called once the command ends or is interrupted.\r\n  @Override\r\n  public void end(boolean interrupted) {\r\n    Logger.log(\"TurnCommand\", 2, String.format(\"end(%b)\", interrupted));\r\n\r\n    m_subsystem.setPower(0, 0);\r\n  }\r\n\r\n  \/\/ Returns true when the command should end.\r\n  @Override\r\n  public boolean isFinished() {\r\n    Logger.log(\"TurnCommand\", -1, \"isFinished()\");\r\n\r\n    int delta = m_leftEncoder.get() - m_rightEncoder.get();\r\n\r\n    return (Math.abs(delta) >= Math.abs(m_angle));\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<p>Note that if we want to be able to set the\u00a0<strong>angle<\/strong>\u00a0in degrees, we will need to figure out a conversion factor that\u00a0will convert degrees to the arbitrary encoder units returned by the encoders.\u00a0For now\u00a0we will\u00a0pass in an\u00a0<strong>angle<\/strong>\u00a0in the encoder units and see how far the robot turns. Configure the\u00a0<strong>RobotContainer<\/strong> class so that this command will be executed with\u00a0<strong>0.3<\/strong>\u00a0speed for and\u00a0<strong>angle<\/strong>\u00a0of\u00a0<strong>1500<\/strong> when we press button\u00a0<strong>5<\/strong>\u00a0on the joystick. When you have made that change, compare it to the code below.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/*----------------------------------------------------------------------------*\/\r\n\/* Copyright (c) 2018-2019 FIRST. All Rights Reserved.                        *\/\r\n\/* Open Source Software - may be modified and shared by FRC teams. The code   *\/\r\n\/* must be accompanied by the FIRST BSD license file in the root directory of *\/\r\n\/* the project.                                                               *\/\r\n\/*----------------------------------------------------------------------------*\/\r\n\r\npackage frc.robot;\r\n\r\nimport edu.wpi.first.wpilibj2.command.Command;\r\nimport edu.wpi.first.wpilibj2.command.button.CommandJoystick;\r\nimport frc.robot.commands.DriveForTimeCommand;\r\nimport frc.robot.commands.TestMotorSpeedCommand;\r\nimport frc.robot.commands.TurnCommand;\r\nimport frc.robot.commands.ArcadeDriveCommand;\r\nimport frc.robot.commands.CalibrateSpeedCommand;\r\nimport frc.robot.commands.DriveForDistanceCommand;\r\nimport frc.robot.subsystems.DriveSubsystem;\r\nimport frc.robot.subsystems.ExampleSubsystem;\r\n\r\n\/**\r\n * This class is where the bulk of the robot should be declared. Since\r\n * Command-based is a \"declarative\" paradigm, very little robot logic should\r\n * actually be handled in the {@link Robot} periodic methods (other than the\r\n * scheduler calls). Instead, the structure of the robot (including subsystems,\r\n * commands, and button mappings) should be declared here.\r\n *\/\r\npublic class RobotContainer {\r\n  \/\/ The robot's subsystems and commands are defined here...\r\n  @SuppressWarnings(\"unused\")\r\n  private final ExampleSubsystem m_exampleSubsystem = new ExampleSubsystem();\r\n  private final DriveSubsystem m_driveSubsystem = new DriveSubsystem();\r\n  private final CommandJoystick m_joystick = new CommandJoystick(0);\r\n\r\n\r\n  private final ArcadeDriveCommand m_autoCommand = null; \/\/ new ExampleCommand(m_exampleSubsystem);\r\n\r\n  \/**\r\n   * The container for the robot. Contains subsystems, OI devices, and commands.\r\n   *\/\r\n  public RobotContainer() {\r\n    m_driveSubsystem.setDefaultCommand(new ArcadeDriveCommand(m_driveSubsystem, m_joystick));\r\n\r\n    \/\/ Configure the button bindings\r\n    configureButtonBindings();\r\n  }\r\n\r\n  \/**\r\n   * Use this method to define your button->command mappings. Buttons can be\r\n   * created by instantiating a {@link GenericHID} or one of its subclasses\r\n   * ({@link edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then\r\n   * passing it to a {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.\r\n   *\/\r\n  private void configureButtonBindings() {\r\n    m_joystick.button(1).onTrue(new DriveForTimeCommand(m_driveSubsystem, 0.50, 3.0));\r\n    m_joystick.button(2).onTrue(new DriveForDistanceCommand(m_driveSubsystem, 0.75, 30));\r\n    m_joystick.button(3).onTrue(new TestMotorSpeedCommand(m_driveSubsystem));\r\n    m_joystick.button(4).whileTrue(new CalibrateSpeedCommand(m_driveSubsystem));\r\n    m_joystick.button(5).onTrue(new TurnCommand(m_driveSubsystem, 0.3, 1500));\r\n  }\r\n\r\n  \/**\r\n   * Use this to pass the autonomous command to the main {@link Robot} class.\r\n   *\r\n   * @return the command to run in autonomous\r\n   *\/\r\n  public Command getAutonomousCommand() {\r\n    \/\/ An ExampleCommand will run in autonomous\r\n    return m_autoCommand;\r\n  }\r\n}\r<\/code><\/pre>\n\n\n\n<p>Now deploy and run your program and see how far the robot turns. Try and find a number to replace the&nbsp;<strong>1500 <\/strong>value that will make the robot turn exactly&nbsp;<strong>360<\/strong>&nbsp;degrees.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>.<\/p>\n\n\n\n<p>In my case I found that approximately\u00a0<strong>1850 <\/strong>encoder units will make the robot turn\u00a0<strong>360<\/strong>\u00a0degrees. This means that if the input angle is in degrees, we need to multiply it by\u00a0<strong>(1850\/ 360)<\/strong>\u00a0to get the number of encoder units that we need. Implementing this in the code we get:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  public TurnCommand(DriveSubsystem subsystem, double speed, double angle) {\r\n    Logger.log(\"TurnCommand\", 3, \"TurnCommand()\");\r\n\r\n    m_subsystem = subsystem;\r\n    m_speed = speed;\r\n    m_angle = angle * k_ticksPerDegree;\r\n    m_leftEncoder = m_subsystem.getLeftEncoder();\r\n    m_rightEncoder = m_subsystem.getRightEncoder();\r\n\r\n    \/\/ Use addRequirements() here to declare subsystem dependencies.\r\n    addRequirements(m_subsystem);\r\n  }<\/code><\/pre>\n\n\n\n<p>Where I have defined <strong>k_ticksPerDegree<\/strong> as:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  private final double k_ticksPerDegree = 1850.0 \/ 360;<\/code><\/pre>\n\n\n\n<p>Note that I have used <strong>1850.0<\/strong> rather than just <strong>1800<\/strong> because I need to force it to use floating point when evaluating the expressiong.<\/p>\n\n\n\n<p>Now change the line in the\u00a0<strong>RobotContainer<\/strong>\u00a0to turn the robot by\u00a0<strong>180<\/strong>\u00a0degrees:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_button5.whenPressed(new TurnCommand(m_driveSubsystem, 0.3, 180));<\/code><\/pre>\n\n\n\n<p>Before moving on, verify that if you specify a negative&nbsp;<strong>angle<\/strong>&nbsp;the robot will turn the other way:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    m_button5.whenPressed(new TurnCommand(m_driveSubsystem, 0.3, -180));<\/code><\/pre>\n\n\n\n<p>You may find that the robot does not turn exactly the desired <strong>180 <\/strong>degrees. This is because the accuracy of the turns using this method is poor because of wheel slippage and other issues. If the robot had a gyroscope, we could use that for more accurate turns, but since it does not, we will need to live with the inaccuracies.<\/p>\n\n\n\n<p><a href=\"\/combining-commands\/\" data-type=\"page\">Next: Combining Commands<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Next we are going to create a command called&nbsp;TurnCommand&nbsp;which will allow us to turn the robot in place by a specified angle. You should know enough now to create the framework for this command. We will want to specify the speed&nbsp;to be used in the turn as well as the angle so create the constructor&hellip;&nbsp;<a href=\"http:\/\/programming.team2102.org\/turn-command\/\" class=\"\" rel=\"bookmark\">Read More &raquo;<span class=\"screen-reader-text\">Turn Command<\/span><\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"open","template":"","meta":{"neve_meta_sidebar":"","neve_meta_container":"","neve_meta_enable_content_width":"","neve_meta_content_width":0,"neve_meta_title_alignment":"","neve_meta_author_avatar":"","neve_post_elements_order":"","neve_meta_disable_header":"","neve_meta_disable_footer":"","neve_meta_disable_title":""},"_links":{"self":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/225"}],"collection":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/comments?post=225"}],"version-history":[{"count":17,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/225\/revisions"}],"predecessor-version":[{"id":3265,"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/pages\/225\/revisions\/3265"}],"wp:attachment":[{"href":"http:\/\/programming.team2102.org\/wp-json\/wp\/v2\/media?parent=225"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}